# 1. 연산 코드와 오퍼랜드
- 컴퓨터의 명령어는 무엇을 대상으로 어덯게 작동하라라고 하는 구조로 되어 있다
- 명령어는 연산 코드와 오퍼랜드로 구분된다
1) 연산 코드
   - 명령어가 수행할 연산
   - 연산자로도 불림
   - 연산 코드가 담긴 영역을 연산 코드 필드라고 부름
2) 오퍼랜드
   - 연산에 사용할 데이터가 저장된 위치
   - 피연산자로도 불림
   - 오퍼랜드가 담긴 영역을 오퍼랜드 필드라고 부름

## 1) 오퍼랜드
- 오퍼랜드의 필드에는 숫자, 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다
- 많은 경우 연산에 사용할 데이터가 저장된 주소나 레지스터 이름이 온다
  - 오퍼랜드 필드를 주소 필드라고도 부른다

## 2) 연산 코드
- 가장 기본적인 연산 코드의 유형은 크게 네가지
### 2-1) 데이터 전송
- MOVE : 데이터를 옮겨라
- STORE : 데이터를 저장하라
- LOAD(FETCH) : 메모리에서 CPU 로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라

### 2-2) 산술/논리 연산
- ADD, SUBTRACT, MULTIPLY, DIVIDE : 덧셈, 뺄샘, 곱셈, 나눗셈을 수행하라
- INCREMENT, DECREMENT : 오퍼랜드에 1을 더하라, 1을 빼라
- AND, OR, NOT : and, or, not 의 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라

### 2-3) 제어 흐름 변경
- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서로 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL 을 호출할 떄 저장했던 주소로 돌아가라

### 2-4) 입출력 제어
- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

# 2. 주소 지정 방식
- <연산 코드, 연산 코드에 사용될 데이터> 형식을 사용하지 않고 <연산코드, 오퍼랜드 필드> 로 하는 이유는 명령어 길이 때문
- 하나의 명령어가 n 비트로 구성되고, 그중 연산 코드 필드가 m 비트라 가정
- 오퍼랜드 필드의 길이는 연산 코드만큼 길이를 뺀 n-m 비트가 된다
### eg)
- 명령어의 크기가 16비트
- 연산 코드 필드가 4비트
- 주소 명령어는 2-주소 명령어
- 오퍼랜드 필드당 6비트 정도밖에 남지 않는다
  - 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2^6 개밖에 되지 않는다
- 3-주소 명령어가 된다면 2^4 개 밖에 되지 않는다

하지만 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다
- 메모리 주소가 16비트를 저장할 수 있다면
- 그 오퍼랜드 필드는 2^16 의 정보 가짓수를 가지게 된다

1. 유효 주소
   - 연산 코드에 사용할 데이터가 저장되는 위치를 의미한다
2. 주소 지정 방식
   - 오퍼랜드 필드에 데이터가저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
   - 쉽게 설명하면 유효 주소를 찾는 방법

## 2-1) 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼 랜드 필드에 직접 명시
- 데이터의 크기는 작아진다는 단점
- 단, 속도는 빠름

## 2-2) 직접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소를 직접 명시
- 데이터 크기는 즉시 주조 지정 방식보다 커짐
- 하지만 유효 주소 표현할 수 있는 범위는 연산 코드의 비트 수만큼 줄어듦

## 2-3) 간접 주소 지정 방식
- 유효 주소의 주소를 오퍼랜드 필드에 직접 명시
- 유효 주소의 범위가 넓어짐
- 단, 두 번의 메모리 접근이 필요하기에 상대적으로 느린 방식

## 2-4) 레지스터 주소 지정 방식
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- CPU 외부 메모리의 데이터 접근보다 내부 레지스터리에 접근하는 것이 더 빠르다

## 2-5) 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이러틀 메모리에 저장
- 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만 메모리 접근 횟수가 한 번뿐

# 3. 스택과 큐
## 3-1) 스택
- 한쪽 끝이 막힌 통과 같은 저장 공간
- 차곡차곡 저장하고 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터부터 빼낸다
- 후입선출
- LIFO (Last In First Out)
- 스택에 새로운 데이터를 저장하는 명령어가 PUSH
- 저장된 데이터를 꺼내는 명령어가 POP

## 3-2) 큐
- 양쪽이 뚫려 있는 통과 같은 저장 공간
- 한쪽으로는 데이터를 저장하고 다른 한 쪽으로는 먼저 저장한 순서대로 데이터를 빼냄
- 선입 선출
- FIFO (First In First Out)
