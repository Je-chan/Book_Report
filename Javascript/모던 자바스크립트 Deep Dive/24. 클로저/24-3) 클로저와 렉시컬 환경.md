# 클로저와 렉시컬 환경

```jsx
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```

- outer ㅎ마수를 호출하면 outer 함수는 중첩 함수 inner 를 반환하고 생명 주기를 마감한다.
  - outer 함수의 실행이 종료되면 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거
  - outer 함수의 지역 변수 x 와 변수 값 10 을 저장하고 있던 outer 함수의 실행 컨텍스트가 제거됐으므로 outer 함수의 지역 변수 x 도 생명 주기를 마감
- 그러나 실행 결과는 10. 지역 변수 x 에 대한 참조가 유지

### 클로저란

> **외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다**
>
> **이를 클로저라 한다**

- 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다
- 함수를 어디서 호출하든 상관 없이 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조하며 식별자에 바인딩된 값을 변경할 수도 있다
- outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다
- **하지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다**
  - outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있음
  - inner 함수는 전역 변수 InnerFunc 에 의해 참조되고 있음
  - 그 결과, 가비지 컬렉션의 대상이 되지 않음

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다

**하지만 모든 함수를 클로저라 하지 않는다.**

```jsx
function foo() {
  const x = 1;
  const y = 2;

  // 일반적으로 클로저라 하지 않는다
  function bar() {
    const z = 3;

    // 상위 스코프의 식별자를 참조하지 않고 있음
    console.log(z);
  }

  return bar;
}

const bar = foo();
bar();
```

- bar 함수는 상위 스코프의 어떤 식별자도 참조하지 않는다
- 고로, 클로저라 하지 않는다.

```jsx
function foo() {
  const x = 1;
  const y = 2;

  function bar() {
    // 상위 스코프의 식별자를 참조하고 있음
    console.log(x);
  }

  // 그러나 bar 함수의 생명주기가 foo보다 짧음
  bar();
}

foo();
```

- 외부 함수 foo 보다 중첩 함수 bar 의 생명 주기가 짧다
- 이런 경우, 중첩 함수 bar 는 클로저였으나 일찍 소멸되므로 함수의 식별자를 참조할 수 있다는 클로저의 본질에 부합하지 않는다.

> **클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다**

- 클로저에 의해 참조되는 상위 스코프의 변수를 자유변수라 부른다 (free variable)
- 클로저란 함수가 자유 변수에 의해 닫혀 있다는 의미로 Closure 다
- 클로저의 메모리 점유는 필요한 것을 기억하기 위한 것이므로 메모리 누수를 걱정할 필요는 없다
- 오히려, 클로저는 자바스크립트의 강력한 기능으로, 필요하다면 적극적으로 활용해야 한다.
