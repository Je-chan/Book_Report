# 함수 정의
- 함수를 정의하는 방법은 4가지가 있다.
  - 변수는 선언한다고 표현하지만 함수는 정의한다고 표현한다.
  - 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되기 때문
  - 다른 프로그래밍 언어에서는 선언과 정의를 엄격하게 구분하기도 한다.
    - C : 선언과 정의의 차이는 실제로 메모리 주소를 할당하는가로 구분한다.
    - 컴파일러에게 식별자의 존재만을 알리는 것은 선언.
    - 실제로 컴파일러가 변수를 생성해서 식별자와 메모리 주소가 연결되면 정의.
    - 자바스크립트의 경우, 변수를 선언하면 암묵적으로 정의가 이뤄지므로 그 구분이 모호하다
## (1) 함수 선언문
```typescript jsx
function add(x, y) {
	return x + y
}
```
- 함수 선언문은 함수 리터럴과 형태가 동일하다.
- 단, 함수 리터럴은 함수 이름을 생략할 수 있지만 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다.
  - 표현식인 문과 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해보는 것
  - 표현식이 아닌 문은 값으로 평가할 수 없기 때문
	- 이는 평가된 값을 반환하면 표현식인 것이고, 아니라면 표현식이 아닌 문이라는 것.
- 하지만 아래의 예제를 보면 함수 선언문이 변수에 할당되는 것처럼 보인다.
```typescript jsx
const add = function add(x, y) {
	return x + y
}

console.log(add(1, 2)) // 3
```
- 이렇게 동작하는 이유는 자바스크립트 엔진이 코드 문맥에 따라서 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문
  - {} 
  - 자바스크립트 엔진은 이 중괄호를 블록문으로 해석하기도 하고, 값이 평가되는 경우 객체 리터럴로 해석하기도 한다
- 기명 함수 리터럴도 중의적인 코드이므로, 코드의 문맥에 따라 해석이 달라진다.

### 암묵적 식별자 생성
- 자바스크립트 엔진은 함수 선언문을 해석해서 함수 객체를 생성한다.
- 이때, 함수 이름은 함수 몸체 내부에서만 유효한 식별자이기 떄문에 함수 이름과는 별도로 생성된 함수 객체를 가리킬 식별자가 필요하다
- <b>*자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당한다.*</b>
  - 함수는 함수 이름으로 호출하는 것이 아니다.
  - 함수 객체를 가리키는 식별자로 호출한다.
  - 함수 이름으로 호출할 수 있는 곳은 함수 몸체 내부다.

## (2) 함수 표현식
- 자바스크립트의 함수는 객체 타입의 값이다.
- 자바스크립트의 함수는 <b>*일급 객체다*</b>
  - 함수를 값처럼 자유롭게 사용할 수 있다는 것
- 일급 객체이기 때문에 함수 표현식이 가능하다
```typescript jsx
const add = function (x, y) {
	return x + y
}
```
- 함수 표현식에서 함수 리터럴은 익명함수로 쓰는 것이 일반적이다.
- 함수 이름은 함수 몸체 내에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수는 없다
```typescript jsx
const add = function foo(x, y) {
	return x = y
}

add(1, 2) // 3
foo(1, 3) // ReferenceError : foo is not defined
```

## (3) 함수 생성 시점과 함수 호이스팅
- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- 이유는 정의한 함수의 생성 시점이 다르기 때문이다

### (3-1) 함수 호이스팅
- 모든 선언문이 그렇듯, 함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다
  - 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성
  - 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 객체 할당
- 즉, 런타임에는 이미 함수 객체가 생성되어 있어 함수 이름과 동일한 식별자에 할당까지 완료된 상태다
- 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.
- 이런 현상을 함수 호이스팅이라 한다.

### (3-2) 함수 호이스팅과 변수 호이스팅의 차이
- var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 먼저 실행돼 식별자를 생성한다는 점에서 동일하다
- 하지만, var 키워드로 선언된 변수는 undefined 로 초기화된다.
- 함수 선언문으로 생성된 식별자는 함수 객체로 초기화된다.
  - 이렇기 때문에 호출이 가능한 것

### (3-3) 함수 표현식은 왜 호이스팅이 일어나지 않는가
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다.
- 변수 선언은 런타임 이전에 실행돼 undefined 로 초기화된다.
- 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 그러므로 함수 표현식으로 함수를 정의함녀 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.
- 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙을 무시하므로 선언문 대신 표현식 사용을 권장한다

## (4) Function 생성자 함수
- 생성자 함수란 객체를 생성하는 함수를 뜻한다.
- Function 생성자 함수로 add 함수를 생성해보면 다음과 같다
```typescript jsx
const add = new Function('x', 'y', 'return x + y')
```
- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지도 않고 바람직하지도 않다
  - 클로저를 생성하지 못한다
  - 즉, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.
```typescript jsx
const add2 = (function() {
	let a = 1;
	return new Function('x', 'y', 'return x + y + a')
}())

console.log(add2(1, 2)) // ReferenceError a is not defined
```

## (5) 화살표 함수
- 화살표 함수는 function 키워드 대신 화살표 => 를 사용해 좀더 간략한 방법으로 함수를 선언하는 방식이다
- 화살표 함수는 항상 익명 함수로 정의한다
```typescript jsx
const add = (x, y) => x + y
```
- 화살표 함수가 기존의 함수 선언문과 표현식을 완전히 대체하기 위해 디자인 된 것은 아니다.
- 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작도 간략화 돼있다.

1. 화살표 함수는 생성자 함수로 사용할 수 없다.
2. 기존 함수와 this 바인딩 방식이 다르다
3. prototype 프로퍼티가 없다
4. arguments 객체를 생성하지 않는다.

