# 원시 값과 래퍼 객체
- 원시 값에도 객체를 생성하는 표준 빌트인 객체가 존재하는 이유는 무엇인가?
```typescript jsx
const str = 'string'

console.log(str.length) // 6
console.log(str.toUpperCase()) // STRING
```

- 원시값을 리터럴로 생성해도 객체처럼 사용할 수 있다.
- 이는 자바스크립트 엔진이 원시값을 연관된 객체로 변환해주기 때문이다
  - 즉, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성한다
  - 이후, 이 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌리는 일을 한다
- 이렇게 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼객체라고 한다
  - Wrapper Object
- 이렇게 생성된 래퍼 객체는 가비지 컬렉션의 대상이 된다

```typescript jsx
// (1) 식별자 str 은 string 이라는 문자열을 값으로 가지고 있다
const str = 'string'

// (2) 식별자 str 은 암묵적으로 생성된 래퍼 객체를 가리킨다
// str 의 값인 string 은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다
// 래퍼 객체의 name 프로퍼티가 동적으로 추가 된다
str.name = 'Good'

// (3) 식별자 str 은 다시 원래의 문자열, 즉, 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시 값을 갖는다
// 이때 위에서 생성한 래퍼 객체는 아무도 참조하지 않으므로 가비지 컬렉션의 대상이 된다

// (4) 식별자 str 은 (2) 의 방식철검 새롭게 암묵적으로 생성된 래퍼 객체를 가리키게 된다
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않는다
console.log(str.name) // undefined

// (5) 식별자 str 은 다시 원래의 문자열, [[StringData]] 에 할당되었던 원시값을 갖는다
// 이때, (4) 에서 생성된 래퍼 객체를 아무도 사용하지 않으므로 가비지 컬렉션의 대상이 된다
console.log(typeof str, str) // string, string
```
- 이는 다른 원시타입들도 마찬가지다
- 심벌 또한 래퍼 객체를 생성한다. 
  - 단지, 심벌은 리터럴 표기법으로 생성할 수 없다

